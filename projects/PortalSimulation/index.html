<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Portal Simulation • WebGL</title>
  <style>
    :root{color-scheme:dark light;--bg:#0c1116;--panel:#0f1520;--text:#e6edf3;--muted:#9fb0c0;--accent:#58a6ff}
    html,body{margin:0;background:var(--bg);color:var(--text);font:16px/1.55 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
    a{color:var(--accent);text-decoration:none} a:hover{text-decoration:underline}
    .container{max-width:1100px;margin:0 auto;padding:28px 16px 64px}
    header.page{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:16px}
    header .title{display:flex;flex-direction:column;gap:4px}
    header h1{margin:0;font-weight:700;font-size:clamp(22px,3.2vw,34px);letter-spacing:.2px}
    header .subtitle{margin:0;color:var(--muted);font-size:14px}
    .controls{display:flex;gap:10px}
    .btn{appearance:none;border:1px solid #263345;background:#152033;color:var(--text);padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
    .btn:hover{background:#1b2a42}

    .stage-wrap{margin:18px 0 12px;display:grid;place-items:center}
    .stage{width:1024px;height:768px;background:#000;border-radius:12px;box-shadow:0 20px 60px rgba(0,0,0,.45);position:relative;overflow:hidden}
    .stage iframe{position:absolute;inset:0;width:100%;height:100%;border:0;background:#000}
    .overlay{pointer-events:none;position:absolute;inset:0;display:grid;place-items:center;color:#fff;text-shadow:0 2px 12px rgba(0,0,0,.6);background:linear-gradient(to bottom, rgba(0,0,0,.15), rgba(0,0,0,.25));font-weight:700;letter-spacing:.2px;opacity:.9;transition:opacity .15s ease}
    .overlay.hidden{opacity:0;pointer-events:none}

    .info{margin-top:10px;color:var(--muted);font-size:14px;text-align:center}
    section{background:var(--panel);border:1px solid #1b2636;border-radius:12px;padding:16px;margin-top:24px}
    section h2{margin:0 0 8px;font-size:18px}
    section p{margin:6px 0}
    .kbd{font:600 12px/1 ui-monospace,SFMono-Regular,Consolas,monospace;padding:3px 6px;border-radius:6px;border:1px solid #263345;background:#111826;color:#cfe1ff}
  </style>
</head>
<body>
  <div class="container">
    <header class="page">
      <div class="title">
        <h1>Portal Simulation</h1>
        <p class="subtitle">WebGL build – click the window to play (W/A/S/D • Mouse • Space)</p>
      </div>
      <div class="controls">
        <button class="btn" id="btnFullscreen">Fullscreen</button>
      </div>
    </header>

    <div class="stage-wrap">
      <div class="stage" id="stage">
        <iframe id="gameframe"
                src="app/index.html"
                title="Portal Simulation"
                allow="fullscreen; gamepad; pointer-lock; keyboard-map"
                allowfullscreen></iframe>
        <div class="overlay" id="overlay">Click to play</div>
      </div>
    </div>
    <div class="info">Esc releases pointer; Esc in fullscreen exits fullscreen first, then click the window to lock again.</div>

    <section>
      <h2>About this project</h2>
      <p>
        C++/OpenGL (WebGL2 via Emscripten) prototype with
        <strong>shadow mapping</strong>, <strong>stencil-buffer portal masking</strong>, and
        offscreen <strong>portal scene capture</strong>.
      </p>
      <p>
        Controls:
        <span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> move,
        <span class="kbd">Mouse</span> look, <span class="kbd">Space</span> jump.
      </p>
    </section>
  </div>

  <script>
    (function () {
      const stage   = document.getElementById('stage');
      const frame   = document.getElementById('gameframe');
      const overlay = document.getElementById('overlay');
      const btnFS   = document.getElementById('btnFullscreen');

      function getInner() {
        const w = frame.contentWindow;
        if (!w) return {};
        const doc = w.document;
        const Module = w.Module || {};
        const canvas = Module.canvas || (doc && doc.getElementById('canvas'));
        return { w, doc, Module, canvas };
      }

      function prepareInnerDocument() {
        const { doc, canvas } = getInner();
        if (!doc) return;

        // Hide default emscripten UI bits and disable scrolling in the iframe
        const hideCSS = doc.createElement('style');
        hideCSS.textContent = `
          #status, #controls, #output, #emscripten_logo { display:none !important; }
          html, body { margin:0!important; padding:0!important; height:100%; overflow:hidden!important; }
          canvas { display:block; outline:none; }
        `;
        doc.head.appendChild(hideCSS);

        if (canvas) {
          canvas.setAttribute('tabindex', '0');

          // *** KEY FIX ***
          // Listen INSIDE the iframe: click on canvas => focus + requestPointerLock + hide overlay
          canvas.addEventListener('mousedown', () => {
            try { canvas.focus(); } catch(e) {}
            if (canvas.requestPointerLock) { try { canvas.requestPointerLock(); } catch(e) {} }
            hideOverlay();
          });

          // If pointer lock becomes active (Esc releases it), keep overlay in sync
          doc.addEventListener('pointerlockchange', () => {
            const locked = doc.pointerLockElement === canvas;
            if (locked) hideOverlay(); else showOverlay();
          });
        }
      }

      // Overlay helpers
      function hideOverlay(){ overlay.classList.add('hidden'); }
      function showOverlay(){ overlay.classList.remove('hidden'); }

      // Fallback engage (clicking the frame border area)
      function engage() {
        const { canvas } = getInner();
        if (!canvas) return;
        try { canvas.focus(); } catch(e) {}
        if (canvas.requestPointerLock) { try { canvas.requestPointerLock(); } catch(e) {} }
        hideOverlay();
      }

      // Fullscreen while keeping WASD: fullscreen target = inner canvas if possible
      async function enterFullscreen() {
        const { canvas } = getInner();
        const target = canvas || frame;
        if (!target) return;
        const req = target.requestFullscreen || target.webkitRequestFullscreen;
        if (req) { try { await req.call(target); } catch(e) {} }
        try { target.focus(); } catch(e) {}
        if (canvas && canvas.requestPointerLock) { try { canvas.requestPointerLock(); } catch(e) {} }
        hideOverlay();
      }

      // When exiting fullscreen, ensure subsequent click will re-focus canvas & relock
      function onFSChange() {
        const { doc, canvas } = getInner();
        const fsElem = document.fullscreenElement || document.webkitFullscreenElement ||
                       (doc && (doc.fullscreenElement || doc.webkitFullscreenElement));
        if (!fsElem && canvas) {
          // exited fullscreen — next click on canvas will lock again (handled above)
        }
      }

      // Parent-page reactions to pointer lock toggles inside the iframe
      function wireParentPointerLockSync() {
        const { doc, canvas } = getInner();
        if (!doc || !canvas) return;
        doc.addEventListener('pointerlockchange', () => {
          const locked = doc.pointerLockElement === canvas;
          if (locked) hideOverlay(); else showOverlay();
        });
      }

      // ----- Wire up events -----
      stage.addEventListener('click', engage); // fallback if clicking the chrome around the canvas

      frame.addEventListener('load', () => {
        // Wait a tick so Module.canvas is populated
        setTimeout(() => {
          prepareInnerDocument();
          wireParentPointerLockSync();
        }, 60);
      });

      document.addEventListener('fullscreenchange', onFSChange);
      document.addEventListener('webkitfullscreenchange', onFSChange);
      btnFS.addEventListener('click', enterFullscreen);
    })();
  </script>
</body>
</html>
