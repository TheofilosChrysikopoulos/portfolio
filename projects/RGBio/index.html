<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="../../assets/controllerLogo2.png" type="image/png">
  <title>RGBio ‚Ä¢ Web Demo</title>

  <link rel="stylesheet" href="../../style.css">
  <script defer src="../../script.js"></script>

  <!-- Minimal scoped styles so it still looks good if style.css changes -->
  <style>
    :root {
      --bg: #0b0d12;
      --fg: #e8ecf1;
      --muted: #a4afbf;
      --card: #12161f;
      --line: #1e2633;
      --brand: #6cf0ff;
      --accent: #7df1a8;
    }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, sans-serif; background: var(--bg); color: var(--fg); }
    .project-page { max-width: 1100px; margin: 0 auto; padding: 24px; }
    .topbar { display: flex; gap: 12px; align-items: center; justify-content: space-between; margin-bottom: 16px; }
    .topbar a { text-decoration: none; color: var(--fg); opacity: .9; }
    .btn { display: inline-flex; align-items: center; gap: .5rem; background: var(--card); border: 1px solid var(--line); border-radius: 12px; padding: 10px 14px; color: var(--fg); text-decoration: none; transition: transform .06s ease, border-color .2s ease; }
    .btn:hover { border-color: var(--brand); transform: translateY(-1px); }
    .btn.primary { background: linear-gradient(180deg, #162233, #121a28); border-color: #20324a; }
    h1 { font-size: clamp(28px, 4vw, 40px); line-height: 1.1; margin: 6px 0 8px; letter-spacing: .3px; }
    .subtitle { color: var(--muted); margin: 0 0 18px; }
    .taglist { display: flex; flex-wrap: wrap; gap: 8px; margin: 10px 0 0; }
    .tag { font-size: 12px; padding: 6px 10px; border: 1px solid var(--line); color: var(--muted); border-radius: 999px; background: #0f1420; }
    .hero { background: var(--card); border: 1px solid var(--line); border-radius: 16px; padding: 18px; }
    .demo-wrap { position: relative; background: #0a0f18; border: 1px solid var(--line); border-radius: 14px; overflow: clip; }
    .demo-center { display: flex; align-items: center; justify-content: center; padding: 8px; min-height: 240px; }
    .demo-center iframe { border: 0; display: block; max-width: 100%; }
    .demo-toolbar { display: flex; gap: 8px; justify-content: space-between; align-items: center; padding: 10px 12px; border-top: 1px solid var(--line); background: #0f1420; }
    .muted { color: var(--muted); font-size: 14px; }
    .grid { display: grid; gap: 16px; }
    .two { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    .three { grid-template-columns: repeat(3, minmax(0, 1fr)); }
    .card { background: var(--card); border: 1px solid var(--line); border-radius: 16px; padding: 18px; }
    .card img, .card video { width: 100%; border-radius: 12px; display: block; }
    .section-title { font-size: 20px; margin: 4px 0 12px; }
    .footer { margin: 32px 0 12px; color: var(--muted); font-size: 14px; text-align: center; }
    @media (max-width: 900px) { .two { grid-template-columns: 1fr; } .three { grid-template-columns: 1fr; } }
    #btnMute { width: 44px; justify-content: center; padding-inline: 10px; }
    #btnMute span { line-height: 1; font-size: 18px; }
    .hero, section.card, .footer { margin: 0; }
    .hero + section.card, section.card + section.card, section.card + .footer { margin-top: clamp(18px, 3vw, 40px); }
    .project-page .hero { margin-top: clamp(8px, 1vw, 16px); }

    /* Toolbar wraps cleanly on small screens */
    .demo-toolbar { flex-wrap: wrap; }
    .demo-toolbar .btn-group { display: flex; gap: 8px; flex: 0 1 auto; }
    .demo-toolbar .muted { flex: 1 1 260px; min-width: 200px; }
    @media (max-width: 520px){
      .demo-toolbar { justify-content: center; }
      .demo-toolbar .btn-group { order: 1; width: 100%; justify-content: center; }
      .demo-toolbar .muted { order: 2; flex: 1 1 100%; text-align: center; font-size: 12px; }
      .btn { padding: 8px 10px; font-size: 14px; }
      #btnMute { width: auto; padding-inline: 10px; }
    }

    /* Responsive iframe: good shape before Unity reports */
    #demoFrame {
      width: 100%;
      height: auto;
      aspect-ratio: 16 / 9;   /* fallback until first message sets exact aspect */
      min-height: 240px;
      display: block;
      max-height: 90vh;       /* visual safety cap */
    }
  </style>
</head>
<body>
  <main class="project-page">
    <!-- Top bar -->
    <div class="topbar">
      <div style="display:flex; gap:8px; align-items:center;">
        <a class="btn" href="../../">‚Üê Back to Portfolio</a>
      </div>
      <div style="display:flex; gap:8px;">
        <a class="btn primary" href="#about">About</a>
      </div>
    </div>

    <!-- Hero -->
    <header class="hero">
      <h1>RGBio</h1>
      <p class="subtitle">Mobile tilt-skill game. This page includes a playable WebGL demo and details.</p>
      <div class="taglist">
        <span class="tag">Unity</span><span class="tag">C#</span><span class="tag">HLSL</span><span class="tag">Android</span>
      </div>
    </header>

    <!-- Demo -->
    <section class="card" id="demo">
      <div class="demo-wrap">
        <div class="demo-center">
          <iframe
            id="demoFrame"
            src="./app/index.html"
            title="RGBio WebGL Demo"
            loading="eager"
            fetchpriority="high"
            allow="autoplay; fullscreen; gamepad; xr-spatial-tracking"
            scrolling="no"
            style="overflow:hidden;"
          ></iframe>
        </div>
        <div class="demo-toolbar">
          <span class="muted">Tip: Click inside the window to focus. Press <kbd>Esc</kbd> to exit fullscreen. Inputs: A and D or touch left/right side of the screen for mobile</span>
          <div class="btn-group">
            <button class="btn" id="btnReload" type="button">Reload</button>
            <button class="btn" id="btnFullscreen" type="button">Fullscreen</button>
            <button class="btn" id="btnMute" type="button" aria-pressed="false" aria-label="Mute">
              <span id="iconMuteOn" style="display:none;" aria-hidden="true">üîá</span>
              <span id="iconMuteOff" aria-hidden="true">üîä</span>
            </button>
          </div>
        </div>
      </div>
    </section>

    <!-- About -->
    <section class="card" id="about">
      <h2 class="section-title">About this project</h2>
      <p>
        I built this Android game in my third year in university. Three balls travel along a 3D curved road defined by a B√©zier spline, and the player can rotate them around a shared center to dodge approaching obstacles. 
      </p>
      <p>
        The balls Red, Green and Blue can pass through obstacles of the same color. The result is a skill-based experience that rewards quick decisions and feels especially satisfying when clearing difficult sequences.
      </p>
      <h4>What I learned</h4>
      <p>
        The toughest challenge was designing the physics: moving the balls smoothly along a changing spline while maintaining the illusion that ‚Äúgravity‚Äù keeps them pinned to the track. 
        I also dug into procedural mesh generation in Unity. I began with Sebastian Lague‚Äôs 
        <a href="https://github.com/SebLague/Path-Creator" target="_blank" rel="noopener">Path Creator</a> and extended it for real-time road creation rather than offline level authoring. 
        That process gave me valuable practice reading, understanding, and modifying another developer‚Äôs code. 
        Finally, I built my first Shader Graph to support real-time mesh-deformation effects for the obstacle animation.
      </p>

      <div class="grid two" style="margin-top:10px;">
        <div>
          <h3 class="section-title">Highlights</h3>
          <ul>
            <li>Unity Fundamentals</li>
            <li>Physics</li>
            <li>Procedural Mesh creation</li>
            <li>Animation</li>
            <li>Particle System</li>
          </ul>
        </div>
        <div>
          <h3 class="section-title">Tech</h3>
          <ul>
            <li>Unity 2021 ‚Ä¢ URP</li>
            <li>Android</li>
            <li>C#</li>
          </ul>
        </div>
      </div>
    </section>

    <p class="footer">¬© Theofilos Chrysikopoulos ‚Äî <a href="../../">Back to portfolio</a></p>
  </main>

  <script>
    const frame = document.getElementById('demoFrame');
    let currentMuted = localStorage.getItem('rgbioMuted') === '1';
    // --- ONE-SHOT: receive size once, then stop (prevents infinite growth) ---
    function onUnitySize(ev) {
      if (ev.source !== frame.contentWindow || !ev.data || !ev.data.__unityCanvasSize__) return;
      const { w, h } = ev.data;
      if (!(w > 0 && h > 0)) return;

      // Lock aspect ratio once; let CSS handle future resizing
      frame.style.width = '100%';
      frame.style.height = '';
      frame.style.aspectRatio = `${w} / ${h}`;
      frame.dataset.aspectSet = '1';
      frame.style.maxHeight = '90vh'; // visual safety cap

      // Stop listening after first success
      window.removeEventListener('message', onUnitySize, true);

      // Ask child to stop reporting (defensive)
      try { frame.contentWindow.postMessage({ __stopUnitySizer__: true }, '*'); } catch {}

      document.getElementById('demoLoading')?.remove();
    }
    window.addEventListener('message', onUnitySize, true);

    // --- Also listen for mute state updates (keep your existing behavior) ---
    window.addEventListener('message', (ev) => {
      if (ev.source !== frame.contentWindow || !ev.data) return;
      if (typeof ev.data.__unityMuted__ !== 'undefined') {
        updateMuteIcon(!!ev.data.__unityMuted__);
      }
    });

    // --- Inject sizing cleanup (hide Unity footer + one-shot size reporter) ---
    function injectSizerAndCleanup() {
      try {
        const win = frame.contentWindow;
        const doc = frame.contentDocument || win.document;

        if (doc?.documentElement) doc.documentElement.style.overflow = 'hidden';
        if (doc?.body) doc.body.style.overflow = 'hidden';

        const style = doc.createElement('style');
        style.textContent = `
          #unity-footer, .unity-footer, #unityLogo, #unity-logo,
          #unity-fullscreen-button, .unity-fullscreen-button,
          #footer, .footer { display: none !important; }
          html, body { overflow: hidden !important; }
        `;
        doc.head.appendChild(style);

        // One-shot size reporter (no ResizeObserver / no polling loop)
        const s = doc.createElement('script');
        s.id = 'unity-size-reporter';
        s.textContent = `
          (function () {
            var stopped = false;
            function canvasEl() {
              return (
                document.getElementById('unity-canvas') ||
                (document.getElementById('unityContainer') && document.getElementById('unityContainer').querySelector('canvas')) ||
                document.querySelector('#unity-container canvas') ||
                document.querySelector('canvas')
              );
            }
            function sendOnce() {
              if (stopped) return;
              var c = canvasEl();
              if (!c) return;
              var r = c.getBoundingClientRect();
              try { parent.postMessage({ __unityCanvasSize__: true, w: Math.round(r.width), h: Math.round(r.height) }, '*'); } catch(e){}
              stopped = true;
            }
            window.addEventListener('message', function (ev) {
              var d = ev && ev.data;
              if (d && d.__stopUnitySizer__) { stopped = true; }
            }, true);
            window.addEventListener('load', function(){ setTimeout(sendOnce, 0); });
            setTimeout(sendOnce, 600); // fallback
          })();
        `;
        doc.body.appendChild(s);
      } catch {}
    }

    // --- Inject audio controller (mute/unmute WebAudio + media) ---
    function injectAudioController() {
      try {
        const win = frame.contentWindow;
        const doc = frame.contentDocument || win.document;
        const s = doc.createElement('script');
        s.id = 'unity-audio-controller';
        s.textContent = `
          (function () {
            var AC = window.AudioContext || window.webkitAudioContext;
            var state = { muted: false, contexts: new Set(), mediaEls: new Set(), origResume: null };

            // Restore last session mute if present
            try { state.muted = sessionStorage.getItem('rgbioMuted') === '1'; } catch(e){}

            function remember() {
              try { sessionStorage.setItem('rgbioMuted', state.muted ? '1' : '0'); } catch(e){}
              try { parent.postMessage({ __unityMuted__: state.muted }, '*'); } catch(e){}
            }

            function addIfContext(x){ try { if (AC && x && x instanceof AC) state.contexts.add(x); } catch(e){} }

            // Common Unity locations
            if (window.unityInstance?.Module?.audioContext) addIfContext(window.unityInstance.Module.audioContext);
            if (window.Module?.SDL2?.audioContext) addIfContext(window.Module.SDL2.audioContext);

            // Capture future AudioContexts
            if (AC && !AC.__wrapped) {
              var OrigAC = AC;
              var ProxyAC = new Proxy(OrigAC, { construct(target, args) {
                var ctx = new target(...args);
                try { state.contexts.add(ctx); if (state.muted) { ctx.suspend().catch(()=>{}); } } catch(e){}
                return ctx;
              }});
              ProxyAC.__wrapped = true;
              window.AudioContext = ProxyAC;
              if (window.webkitAudioContext) window.webkitAudioContext = ProxyAC;
            }

            // Block resume while muted (prevents Unity from turning sound back on)
            (function patchResume(){
              if (!AC || state.origResume) return;
              var proto = (AC.prototype || (window.webkitAudioContext && window.webkitAudioContext.prototype));
              if (!proto || !proto.resume) return;
              state.origResume = proto.resume;
              proto.resume = function(){
                if (state.muted) return Promise.resolve();
                return state.origResume.apply(this, arguments);
              };
            })();

            // Track HTML media elements; when muted, KEEP PLAYING but silent
            function tagAsBG(el){
              // Mark background/intro videos so we can safely autoplay them when muted
              if (!el.hasAttribute('data-allow-when-muted')) el.setAttribute('data-allow-when-muted','');
              if (!el.hasAttribute('playsinline')) el.setAttribute('playsinline','');
              if (!el.hasAttribute('muted')) el.muted = true; // property is enough for autoplay
            }

            function trackMedia() {
              document.querySelectorAll('video, audio').forEach(function(el){
                if (!state.mediaEls.has(el)) {
                  state.mediaEls.add(el);
                  // Heuristic: UI/intro videos often have autoplay/loop or a CSS bg class‚Äîallow while muted
                  if (el.tagName === 'VIDEO' && (el.autoplay || el.loop || /intro|menu|bg|background/i.test(el.className))) {
                    tagAsBG(el);
                  }
                  // Apply current mute mode
                  applyMuteToElement(el);
                }
              });
            }

            function applyMuteToElement(el){
              try {
                if (state.muted) {
                  // Silence but don't pause (so UI videos stay visible)
                  el.muted = true;
                  // Try to start background/menu videos silently (allowed by browsers)
                  if (el.tagName === 'VIDEO' && (el.autoplay || el.hasAttribute('data-allow-when-muted'))) {
                    el.play().catch(()=>{ /* ignored; may require user gesture if not muted flag yet */ });
                  }
                } else {
                  // Unmuted: let elements control themselves naturally
                  // No forced play/pause here
                }
              } catch(e){}
            }

            // Observe DOM for new media
            trackMedia();
            var mo = new MutationObserver(trackMedia);
            mo.observe(document.documentElement, { childList: true, subtree: true });

            async function setMuted(m) {
              state.muted = !!m;

              // HTML media: silent while muted; do NOT pause
              state.mediaEls.forEach(applyMuteToElement);

              // WebAudio contexts (Unity): suspend/resume
              for (var ctx of state.contexts) {
                try { state.muted ? await ctx.suspend() : await ctx.resume(); } catch(e){}
              }

              remember();
            }

            window.__getMuted = function(){ return !!state.muted; };
            window.__setMuted = function(m){ return setMuted(!!m); };

            // Accept parent sync (on reloads)
            window.addEventListener('message', function(ev){
              var d = ev && ev.data;
              if (d && d.__setMuteFromParent__ && typeof d.muted === 'boolean') { setMuted(!!d.muted); }
            }, true);

            // Apply initial state
            setMuted(state.muted);
          })();
        `;
        doc.body.appendChild(s);

      } catch {}
    }

    // --- Initialize on iframe load ---
    frame.addEventListener('load', () => {
      injectSizerAndCleanup();
      injectAudioController();
      // Tell child what the current mute is (covers restarts)
      try { frame.contentWindow.postMessage({ __setMuteFromParent__: true, muted: currentMuted }, '*'); } catch {}
    });


    // --- Toolbar controls ---
    document.getElementById('btnReload')?.addEventListener('click', () => {
      try { frame.contentWindow.location.reload(); } catch {}
    });

    document.getElementById('btnFullscreen')?.addEventListener('click', async () => {
      try {
        const win = frame.contentWindow;
        const doc = frame.contentDocument || win.document;
        if (win && typeof win.unityInstance?.SetFullscreen === 'function') {
          win.unityInstance.SetFullscreen(1);
          return;
        }
        const canvas =
          doc.getElementById('unity-canvas') ||
          (doc.getElementById('unityContainer') && doc.getElementById('unityContainer').querySelector('canvas')) ||
          doc.querySelector('#unity-container canvas') ||
          doc.querySelector('canvas');
        if (canvas?.requestFullscreen) await canvas.requestFullscreen();
        else if (doc.documentElement.requestFullscreen) await doc.documentElement.requestFullscreen();
      } catch {}
    });

    const btnMute = document.getElementById('btnMute');
    const iconOn  = document.getElementById('iconMuteOn');
    const iconOff = document.getElementById('iconMuteOff');

    function updateMuteIcon(muted) {
      if (!btnMute) return;
      btnMute.setAttribute('aria-pressed', String(muted));
      btnMute.setAttribute('aria-label', muted ? 'Unmute' : 'Mute');
      if (iconOn)  iconOn.style.display  = muted ? '' : 'none';
      if (iconOff) iconOff.style.display = muted ? 'none' : '';
      currentMuted = !!muted;
      try { localStorage.setItem('rgbioMuted', currentMuted ? '1' : '0'); } catch {}
    }

    btnMute?.addEventListener('click', async () => {
      try {
        const win = frame.contentWindow;
        const getMuted = win.__getMuted;
        const setMuted = win.__setMuted;
        if (typeof setMuted !== 'function') return;
        const isMuted = typeof getMuted === 'function' ? !!getMuted() : false;
        await setMuted(!isMuted);
        updateMuteIcon(!isMuted);
      } catch {}
    });
  </script>
</body>
</html>
